#BlueJ class context
comment0.params=array
comment0.target=void\ print(int[])
comment1.params=array
comment1.target=boolean\ sorted(int[])
comment10.params=array
comment10.target=int[]\ merge2(int[])
comment10.text=\n\ \ \ \ public\ static\ int[]\ tree(int[]\ array)//O(NlogN)\n\ \ \ \ {\n\ \ \ \ Integer[]\ tree\=new\ Integer[Math.min(3000000,\ (int)(Math.pow(2,\n\ \ \ \ array.length)))];\n\ \ \ \ for\ (int\ i\=0;\ i<array.length;\ i++)//add\ to\ the\ tree\n\ \ \ \ {\n\ \ \ \ int\ position\=1;\n\ \ \ \ while\ (tree[position]\!\=null)\n\ \ \ \ {\n\ \ \ \ if\ (array[i]<\=tree[position])\n\ \ \ \ {\n\ \ \ \ position\=2*position;\n\ \ \ \ }\n\ \ \ \ else\n\ \ \ \ {\n\ \ \ \ position\=2*position+1;\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ tree[position]\=array[i];\n\ \ \ \ }\n\ \ \ \ for\ (int\ i\=0;\ i<array.length;\ i++)\n\ \ \ \ {\n\ \ \ \ //remove\ the\ lowest\ value\ from\ the\ tree\ and\ put\ it\ in\ array[i]\n\ \ \ \ int\ position\=1;\n\ \ \ \ while\ (true)\n\ \ \ \ {\n\ \ \ \ if\ (tree[2*position]\!\=null)\n\ \ \ \ {\n\ \ \ \ tree[position]\=null;\n\ \ \ \ break;\n\ \ \ \ }\n\ \ \ \ else\n\ \ \ \ {\n\ \ \ \ position*\=2;\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ return\ array;\n\ \ \ \ }\n
comment11.params=array
comment11.target=int[]\ counting(int[])
comment11.text=public\ static\ int[]\ radix(int[]\ array)\n\ \ \ \ {\n\ \ \ \ /*\n\ \ \ \ int\ greatest\=0;\n\ \ \ \ for\ (int\ i\=0;\ i<array.length;\ i++)\n\ \ \ \ {\n\ \ \ \ if\ (array[i]>greatest)\n\ \ \ \ {\n\ \ \ \ greatest\=array[i];\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ for\ (int\ pow\=1;\ pow<\=greatest;\ pow*\=10)\n\ \ \ \ {\n\ \ \ \ ArrayList<Queue<Integer>>\ digits\=new\ ArrayList<Queue<Integer>>();\n\ \ \ \ for\ (int\ i\=0;\ i<10;\ i++)\n\ \ \ \ {\n\ \ \ \ digits.add(new\ Queue<Integer>());\n\ \ \ \ }\n\ \ \ \ for\ (int\ i\=0;\ i<array.length;\ i++)\n\ \ \ \ {\n\ \ \ \ int\ edited\=array[i]/pow;\n\ \ \ \ edited\=edited%10;\n\ \ \ \ digits.get(edited).add(array[i]);\n\ \ \ \ }\n\ \ \ \ int\ i\=0;\n\ \ \ \ for\ (int\ j\=0;\ j<10;\ j++)\n\ \ \ \ {\n\ \ \ \ while\ (\!digits.get(j).isEmpty())\n\ \ \ \ {\n\ \ \ \ array[i]\=digits.get(j).remove();\n\ \ \ \ i++;\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ if\ (pow\=\=1410065408)\n\ \ \ \ {\n\ \ \ \ break;\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ return\ array;\n\ \ \ \ if\ (array.length<2)\n\ \ \ \ {\n\ \ \ \ return\ array;\n\ \ \ \ }\n\ \ \ \ int\ base\=array.length;\n\ \ \ \ ArrayList<Queue<Integer>>\ queues\=new\ ArrayList<Queue<Integer>>();\n\ \ \ \ for\ (int\ i\=0;\ i<base;\ i++)\n\ \ \ \ {\n\ \ \ \ queues.add(new\ Queue<Integer>());\n\ \ \ \ }\n\ \ \ \ int\ greatest\=Integer.MIN_VALUE;\n\ \ \ \ int\ least\=Integer.MAX_VALUE;\n\ \ \ \ for\ (int\ i\=0;\ i<array.length;\ i++)\n\ \ \ \ {\n\ \ \ \ if\ (array[i]>greatest)\n\ \ \ \ {\n\ \ \ \ greatest\=array[i];\n\ \ \ \ }\n\ \ \ \ else\ if\ (array[i]<least)\n\ \ \ \ {\n\ \ \ \ least\=array[i];\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ for\ (int\ i\=0;\ i<array.length;\ i++)\n\ \ \ \ {\n\ \ \ \ array[i]\=array[i]-least;\n\ \ \ \ }\n\ \ \ \ int\ loops\=(int)(Math.log(greatest-least)/Math.log(base))+1;\n\ \ \ \ for\ (int\ i\=0;\ i<loops;\ i++)\n\ \ \ \ {\n\ \ \ \ int\ power\=(int)(Math.pow(base,\ i));\n\ \ \ \ for\ (int\ j\=0;\ j<array.length;\ j++)\n\ \ \ \ {\n\ \ \ \ int\ figure\=(array[j]/power)%base;\n\ \ \ \ queues.get(figure).add(array[j]);\n\ \ \ \ }\n\ \ \ \ int\ index\=0;\n\ \ \ \ for\ (int\ j\=0;\ j<base;\ j++)\n\ \ \ \ {\n\ \ \ \ Queue<Integer>\ q\=queues.get(j);\n\ \ \ \ int\ size\=q.size();\n\ \ \ \ for\ (int\ k\=0;\ k<size;\ k++)\n\ \ \ \ {\n\ \ \ \ array[index]\=q.remove();\n\ \ \ \ index++;\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ for\ (int\ i\=0;\ i<array.length;\ i++)\n\ \ \ \ {\n\ \ \ \ array[i]+\=least;\n\ \ \ \ }\n\ \ \ \ return\ array;\n\ \ \ \ }\n
comment12.params=array
comment12.target=int[]\ insertion2(int[])
comment13.params=array
comment13.target=int[]\ dualpivot(int[])
comment14.params=array\ size
comment14.target=int[]\ insertion(int[],\ int)
comment15.params=array\ spaces
comment15.target=int[]\ shell(int[],\ int[])
comment16.params=array
comment16.target=int[]\ shell(int[])
comment17.params=array
comment17.target=int[]\ dualPivotBogo(int[])
comment17.text=\n\ \ \ \ public\ static\ int[]\ shell(int[]\ array)\ //without\ creating\ a\ new\n\ \ \ \ array.\ One\ would\ think\ this\ would\ be\n\ \ \ \ {\n\ \ \ \ int[]\ spaces\={701,\ 301,\ 132,\ 57,\ 23,\ 10,\ 4,\ 1};//better\ but\ for\n\ \ \ \ some\ reason\ it\ is\ worse\n\ \ \ \ for\ (int\ i\=0;\ i<spaces.length;\ i++)\n\ \ \ \ {\n\ \ \ \ if\ (spaces[i]<array.length)\n\ \ \ \ {\n\ \ \ \ for\ (int\ j\=0;\ j<array.length;\ j+\=spaces[i])\n\ \ \ \ {\n\ \ \ \ int\ compare\=array[j];\n\ \ \ \ array[j]\=0;\n\ \ \ \ int\ k\=j-spaces[i];\n\ \ \ \ boolean\ done\=false;\n\ \ \ \ while\ (\!done)\n\ \ \ \ {\n\ \ \ \ if\ (k<0)\n\ \ \ \ {\n\ \ \ \ array[k+spaces[i]]\=compare;\n\ \ \ \ done\=true;\n\ \ \ \ }\n\ \ \ \ else\ if\ (compare>\=array[k])\n\ \ \ \ {\n\ \ \ \ array[k+spaces[i]]\=compare;\n\ \ \ \ done\=true;\n\ \ \ \ }\n\ \ \ \ else\n\ \ \ \ {\n\ \ \ \ array[k+spaces[i]]\=array[k];\n\ \ \ \ array[k]\=0;\n\ \ \ \ k-\=spaces[i];\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ return\ array;\n\ \ \ \ }\n
comment18.params=array\ size
comment18.target=int[]\ bubble(int[],\ int)
comment19.params=array
comment19.target=int[]\ comb(int[])
comment2.params=array
comment2.target=int[]\ bozo(int[])
comment20.params=array
comment20.target=int[]\ clutch(int[])
comment21.params=array
comment21.target=int[]\ heap2(int[])
comment22.params=array
comment22.target=int[]\ originalheap(int[])
comment23.params=array
comment23.target=int[]\ triHeap(int[])
comment24.params=array\ n
comment24.target=int[]\ naryHeap(int[],\ int)
comment25.params=array
comment25.target=int[]\ map(int[])
comment26.params=array\ i\ j
comment26.target=int[]\ stoogeHelper(int[],\ int,\ int)
comment27.params=array
comment27.target=int[]\ stooge(int[])
comment28.params=array
comment28.target=int[]\ gnome(int[])
comment29.params=array
comment29.target=int[]\ java(int[])
comment3.params=array
comment3.target=int[]\ bubble(int[])
comment30.params=array\ start\ end
comment30.target=void\ mergeHelper(int[],\ int,\ int)
comment31.params=array
comment31.target=int[]\ merge(int[])
comment32.params=array
comment32.target=int[]\ bogo(int[])
comment33.params=array
comment33.target=int[]\ bogobogo(int[])
comment34.params=array\ start\ end
comment34.target=int[]\ merge3helper(int[],\ int,\ int)
comment34.text=public\ static\ int[]\ bogobogo(int[]\ array)\n\ \ \ \ {\n\ \ \ \ int\ num\=1;\n\ \ \ \ while\ (num<array.length)\n\ \ \ \ {\n\ \ \ \ if\ (array[num]>\=array[num-1])\n\ \ \ \ {\n\ \ \ \ num++;\n\ \ \ \ break;\n\ \ \ \ }\n\ \ \ \ ArrayList<Integer>\ list\=new\ ArrayList<Integer>();\n\ \ \ \ for\ (int\ i\=0;\ i<num+1;\ i++)\n\ \ \ \ {\n\ \ \ \ list.add(i);\n\ \ \ \ }\n\ \ \ \ int[]\ newArray\=new\ int[num+1];\n\ \ \ \ for\ (int\ i\=0;\ i<newArray.length;\ i++)\n\ \ \ \ {\n\ \ \ \ newArray[i]\=array[list.remove((int)(Math.random()*list.size()))];\n\ \ \ \ }\n\ \ \ \ boolean\ sorted\=true;\n\ \ \ \ for\ (int\ i\=0;\ i<num;\ i++)\n\ \ \ \ {\n\ \ \ \ if\ (array[i]>array[i+1])\n\ \ \ \ {\n\ \ \ \ sorted\=false;\n\ \ \ \ break;\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ if\ (sorted)\n\ \ \ \ {\n\ \ \ \ num++;\n\ \ \ \ }\n\ \ \ \ else\n\ \ \ \ {\n\ \ \ \ num\=1;\n\ \ \ \ }\n\ \ \ \ }\n\ \ \ \ return\ array;\n}
comment35.params=array
comment35.target=int[]\ merge3(int[])
comment36.params=array\ start\ end
comment36.target=int[]\ mergesertion(int[],\ int,\ int)
comment37.params=array
comment37.target=int[]\ mergesertion(int[])
comment38.params=array
comment38.target=int[]\ quaternaryHeap(int[])
comment39.params=array
comment39.target=int[]\ quinaryHeap(int[])
comment4.params=array
comment4.target=int[]\ cocktail(int[])
comment40.params=array\ n
comment40.target=int[]\ originalNaryHeap(int[],\ int)
comment41.params=list
comment41.target=void\ print(java.util.ArrayList)
comment42.params=array
comment42.target=void\ print(java.lang.Integer[])
comment43.params=array
comment43.target=int[]\ bucket(int[])
comment44.params=array\ base
comment44.target=int[]\ bucket(int[],\ int)
comment45.params=array\ base\ power\ length
comment45.target=int[]\ bucketHelper(int[],\ int,\ int,\ int)
comment46.params=array
comment46.target=int[]\ smartBozo(int[])
comment47.params=array
comment47.target=int[]\ flash(int[])
comment48.params=array
comment48.target=int[]\ test(int[])
comment49.params=array\ start\ end
comment49.target=int[]\ inplaceMerge(int[],\ int,\ int)
comment5.params=array
comment5.target=int[]\ selection(int[])
comment50.params=array
comment50.target=int[]\ inplaceMerge(int[])
comment51.params=array
comment51.target=int[]\ guess(int[])
comment52.params=array
comment52.target=int[]\ primitiveGuess(int[])
comment53.params=array
comment53.target=int[]\ tree234(int[])
comment54.params=array
comment54.target=int[]\ heap(int[])
comment55.params=array\ lo\ hi
comment55.target=void\ quick(int[],\ int,\ int)
comment56.params=array
comment56.target=int[]\ quick(int[])
comment57.params=array
comment57.target=int[]\ jens(int[])
comment58.params=array
comment58.target=int[]\ tenMinute(int[])
comment59.params=array\ figure
comment59.target=int[]\ counting(int[],\ int)
comment6.params=array\ lo\ hi
comment6.target=int[]\ insertion(int[],\ int,\ int)
comment60.params=array
comment60.target=int[]\ radix(int[])
comment61.params=array
comment61.target=int[]\ bitonic(int[])
comment62.params=array\ lo\ hi\ order
comment62.target=void\ bitonic(int[],\ int,\ int,\ boolean)
comment7.params=array
comment7.target=int[]\ insertion(int[])
comment8.params=array
comment8.target=int[]\ tree(int[])
comment9.params=array
comment9.target=int[]\ balancingTree(int[])
numComments=63
